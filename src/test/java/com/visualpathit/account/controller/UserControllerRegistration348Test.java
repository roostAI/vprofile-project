
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-vprofile using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=registration_02c44d1ab0
ROOST_METHOD_SIG_HASH=registration_7b18fa13c9

"""
Scenario 1: Testing registration with a valid user

Details:
  TestName: testRegistrationWithValidUser
  Description: This test scenario is meant to check the functionality of registration with a valid user. The input user's details are valid and expected to pass the userValidator.
Execution:
  Arrange: A User object will be created and populated with valid data. Also, the BindingResult and Model will be set correctly.
  Act: The registration method of the UserController is invoked with the user object, bindingResult and Model.
  Assert: The output of the registration method is asserted to be "redirect:/welcome".
Validation:
  The "redirect:/welcome" implies that the registration was successful. This test is significant as it validates the primary path of the registration method with valid user credentials.

Scenario 2: Registration with invalid user

Details:
  TestName: testRegistrationWithInvalidUser
  Description: This test scenario is designed to verify the functionality when the user's details are invalid with respect to the userValidator.
Execution:
  Arrange: A User object will be created and populated with invalid data. The BindingResult will be made to contain errors.
  Act: The registration from UserController is called with the erroneous user object, the bindingResult containing errors, and the Model.
  Assert: The return value of the registration method will be asserted to be "registration".
Validation:
  The test verifies that if the user submits an invalid form, the method returns "registration", indicating validation failure. This test is essential to ensure the application's security and data integrity.

Scenario 3: Testing autologin after successful registration.

Details:
  TestName: testAutoLoginAfterRegistration
  Description: This test check if the autologin method gets invoked as it should, once a new user successfully registers.
Execution:
  Arrange: A User object will be created and populated with valid data. The BindingResult and Model will be set correctly.
  Act: The registration method of the UserController is invoked with the user object, bindingResult and Model.
  Assert: The mock of the securityService to assert that the autologin() method is called with the correct username and password.
Validation:
  Asserting that the "autologin" method is called corresponds to the user being successfully registered and immediately logged in. This test verifies that the application provides a user-friendly feature of automatic login post-registration.

*/

// ********RoostGPT********

package com.visualpathit.account.controller;

import com.visualpathit.account.model.User;
import com.visualpathit.account.service.SecurityService;
import com.visualpathit.account.service.UserService;
import com.visualpathit.account.validator.UserValidator;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.validation.BindingResult;
import org.springframework.ui.Model;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import com.visualpathit.account.service.ProducerService;
import com.visualpathit.account.utils.MemcachedUtils;
import java.util.List;
import java.util.UUID;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@ExtendWith(MockitoExtension.class)
public class UserControllerRegistration348Test {

	@InjectMocks
	private UserController userController;

	@Mock
	private UserService userService;

	@Mock
	private SecurityService securityService;

	@Mock
	private UserValidator userValidator;

	@Mock
	private BindingResult bindingResult;

	@Mock
	private Model model;

	@Tag("valid")
	@Test
	public void testRegistrationWithValidUser() {
		User userForm = new User();
		userForm.setUsername("john");
		userForm.setPassword("password");
		userForm.setPasswordConfirm("password");

		when(bindingResult.hasErrors()).thenReturn(false);

		String view = userController.registration(userForm, bindingResult, model);

		verify(userValidator, times(1)).validate(userForm, bindingResult);
		verify(userService, times(1)).save(userForm);
		verify(securityService, times(1)).autologin(userForm.getUsername(), userForm.getPasswordConfirm());

		assertEquals("redirect:/welcome", view);
	}

	@Tag("invalid")
	@Test
	public void testRegistrationWithInvalidUser() {
		User userForm = new User();
		userForm.setUsername("john");
		userForm.setPassword("pass");
		userForm.setPasswordConfirm("word");
		when(bindingResult.hasErrors()).thenReturn(true);
		String view = userController.registration(userForm, bindingResult, model);
		verify(userValidator, times(1)).validate(userForm, bindingResult);
		verify(userService, times(0)).save(userForm);
		verify(securityService, times(0)).autologin(userForm.getUsername(), userForm.getPasswordConfirm());
		assertEquals("registration", view);
	}

	@Tag("integration")
	@Test
	public void testAutoLoginAfterRegistration() {
		User userForm = new User();
		userForm.setUsername("john");
		userForm.setPassword("password");
		userForm.setPasswordConfirm("password");
		when(bindingResult.hasErrors()).thenReturn(false);
		userController.registration(userForm, bindingResult, model);
		verify(securityService, times(1)).autologin(userForm.getUsername(), userForm.getPasswordConfirm());
	}

}